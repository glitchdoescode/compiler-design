# LALR Parsing

This document explains LALR parsing by constructing the LALR(1) parsing table for a given grammar and then verifying an input string against it.

**Grammar:**
```
1. E -> E + T
2. E -> T
3. T -> T * F
4. T -> F
5. F -> (E)
6. F -> id
```
**Input String to Verify:** `id + id * id`

---

## 1. LALR Parsing Explained

An **LALR (Look-Ahead LR) parser** is a type of LR parser that is intermediate in power between an SLR and a CLR (Canonical LR) parser.

*   **CLR Parsers:** These are the most powerful LR parsers. They use **LR(1) items**, which are LR(0) items augmented with a lookahead terminal (`A -> α.β, a`). This lookahead specifies that we are looking for this production only when the next input symbol is `a`. This makes CLR parsers very precise and avoids the conflicts that SLR parsers can have. However, the number of states in a CLR parser can be very large for typical grammars, making the resulting parsing table huge.
*   **LALR Parsers:** The LALR parsing table is constructed by taking the collection of LR(1) sets of items and **merging states that have the same set of LR(0) items (the "core")**, regardless of their lookahead symbols. The lookaheads in the new, merged state become the union of the lookaheads from the original states.

**Advantages of LALR:**
*   **Power:** It is significantly more powerful than SLR because it uses more precise lookahead information inherited from the CLR construction. It can handle a much wider range of grammars than SLR.
*   **Table Size:** It produces a parsing table with the same number of states as the SLR parser, which is dramatically smaller than the CLR table.

For these reasons, LALR parsers (like those generated by YACC and Bison) represent a practical and widely used compromise between parsing power and table size.

---

## 2. Constructing the LALR Parsing Table

### Step 1: Augment Grammar and Compute LR(1) Items

**Augmented Grammar:**
```
0. E' -> E
1. E -> E + T
2. E -> T
3. T -> T * F
4. T -> F
5. F -> (E)
6. F -> id
```

The process of building the full LR(1) canonical collection is very verbose. We create sets of items of the form `[A -> α.β, l]`, where `l` is the lookahead terminal. The key step is then to merge states with identical cores.

For instance, the LR(1) process might produce two states like:
*   `I_x = { [F -> id., +], [F -> id., *] }`
*   `I_y = { [F -> id., )], [F -> id., $] }`

Both states have the same core item `F -> id.`. An LALR parser generator would merge them into a single state:
*   `I_xy = { [F -> id., + / * / ) / $] }`

Let's generate the LALR states directly by first creating the LR(0) states (the cores) and then calculating the lookaheads for the reduce items.

**LR(0) States (Cores):**
*   **I₀:** `E'->.E`, `E->.E+T`, `E->.T`, `T->.T*F`, `T->.F`, `F->.(E)`, `F->.id`
*   **I₁:** `E'->E.` , `E->E.+T`
*   **I₂:** `E->T.` , `T->T.*F`
*   **I₃:** `T->F.`
*   **I₄:** `F->(.E)`, `E->.E+T`, `E->.T`, `T->.T*F`, `T->.F`, `F->.(E)`, `F->.id`
*   **I₅:** `F->id.`
*   **I₆:** `E->E+.T`, `T->.T*F`, `T->.F`, `F->.(E)`, `F->.id`
*   **I₇:** `T->T*.F`, `F->.(E)`, `F->.id`
*   **I₈:** `F->(E.)`, `E->E.+T`
*   **I₉:** `E->E+T.` , `T->T.*F`
*   **I₁₀:** `T->T*F.`
*   **I₁₁:** `F->(E).`

**LALR Parsing Table Construction:**
We fill the table using the LR(0) states and calculating lookaheads for reduce actions.
*   `FOLLOW(E) = {+, ), $}`
*   `FOLLOW(T) = {+, *, ), $}`
*   `FOLLOW(F) = {+, *, ), $}`

| State |       | ACTION        |       |     | GOTO    |   |
|:-----:|:-----:|:-------------:|:-----:|:---:|:-------:|:-:|
|       | **+** |    **\***     | **(** | **)** | **id** | **$** | **E** | **T** | **F** |
| **0** |       |               |  s4   |     | s5     |       |   1   |  2    |  3    |
| **1** |  s6   |               |       |     |        | acc   |       |       |       |
| **2** |  R2   |      s7       |       | R2  |        | R2    |       |       |       |
| **3** |  R4   |      R4       |       | R4  |        | R4    |       |       |       |
| **4** |       |               |  s4   |     | s5     |       |   8   |  2    |  3    |
| **5** |  R6   |      R6       |       | R6  |        | R6    |       |       |       |
| **6** |       |               |  s4   |     | s5     |       |       |  9    |  3    |
| **7** |       |               |  s4   |     | s5     |       |       |       |  10   |
| **8** |  s6   |               |       | s11 |        |       |       |       |       |
| **9** |  R1   |      s7       |       | R1  |        | R1    |       |       |       |
| **10**|  R3   |      R3       |       | R3  |        | R3    |       |       |       |
| **11**|  R5   |      R5       |       | R5  |        | R5    |       |       |       |

---

## 3. Verify `id + id * id`

We trace the operation of the LALR parser with the given input string. The parser uses a stack (which holds state numbers) and the input string (appended with `$`).

| Step | Stack             | Input           | Action                                       |
|:----:|:------------------|:----------------|:---------------------------------------------|
| 1    | `0`               | `id + id * id $`| **Shift 5** (ACTION[0, id] = s5)             |
| 2    | `0 5`             | `+ id * id $`   | **Reduce by F->id** (ACTION[5, +] = R6)      |
|      | `0` (pop 1)       | `+ id * id $`   | `GOTO[0, F] = 3`. Push 3.                    |
| 3    | `0 3`             | `+ id * id $`   | **Reduce by T->F** (ACTION[3, +] = R4)       |
|      | `0` (pop 1)       | `+ id * id $`   | `GOTO[0, T] = 2`. Push 2.                    |
| 4    | `0 2`             | `+ id * id $`   | **Reduce by E->T** (ACTION[2, +] = R2)       |
|      | `0` (pop 1)       | `+ id * id $`   | `GOTO[0, E] = 1`. Push 1.                    |
| 5    | `0 1`             | `+ id * id $`   | **Shift 6** (ACTION[1, +] = s6)              |
| 6    | `0 1 6`           | `id * id $`     | **Shift 5** (ACTION[6, id] = s5)             |
| 7    | `0 1 6 5`         | `* id $`        | **Reduce by F->id** (ACTION[5, *] = R6)      |
|      | `0 1 6` (pop 1)   | `* id $`        | `GOTO[6, F] = 3`. Push 3.                    |
| 8    | `0 1 6 3`         | `* id $`        | **Reduce by T->F** (ACTION[3, *] = R4)       |
|      | `0 1 6` (pop 1)   | `* id $`        | `GOTO[6, T] = 9`. Push 9.                    |
| 9    | `0 1 6 9`         | `* id $`        | **Shift 7** (ACTION[9, *] = s7)              |
| 10   | `0 1 6 9 7`       | `id $`          | **Shift 5** (ACTION[7, id] = s5)             |
| 11   | `0 1 6 9 7 5`     | `$`             | **Reduce by F->id** (ACTION[5, $] = R6)      |
|      | `0 1 6 9 7` (pop 1) | `$`             | `GOTO[7, F] = 10`. Push 10.                  |
| 12   | `0 1 6 9 7 10`    | `$`             | **Reduce by T->T*F** (ACTION[10, $] = R3)    |
|      | `0 1 6` (pop 3)   | `$`             | `GOTO[6, T] = 9`. Push 9.                    |
| 13   | `0 1 6 9`         | `$`             | **Reduce by E->E+T** (ACTION[9, $] = R1)     |
|      | `0` (pop 3)       | `$`             | `GOTO[0, E] = 1`. Push 1.                    |
| 14   | `0 1`             | `$`             | **Accept** (ACTION[1, $] = acc)              |

The parser reaches the `accept` state with an empty input buffer. Therefore, the string `id + id * id` is **successfully accepted** by the grammar. 