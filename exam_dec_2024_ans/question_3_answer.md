# Answer to Question 3

---

### (a) What is a parser? Explain backtracking and non-backtracking parsers with their types.

A **parser**, also known as a syntax analyzer, is the phase of a compiler that takes the stream of tokens generated by the lexical analyzer and verifies that the stream can be generated by the grammar for the source language. It constructs a parse tree or other syntax tree, which represents the grammatical structure of the token stream. If the token stream cannot be derived from the grammar, the parser reports a syntax error.

Parsers are generally classified into two main types: top-down and bottom-up. The concepts of backtracking and non-backtracking primarily apply to **top-down parsers**.

#### Backtracking Parsers
A **backtracking parser** is a type of parser that uses a trial-and-error approach. When faced with multiple production choices for a non-terminal, it picks one, and if that choice leads to a dead end (a mismatch with the input string), the parser "backtracks" by resetting the input pointer to its previous position and trying the next alternative production.

*   **Type:** A brute-force Recursive Descent Parser is a classic example of a parser that uses backtracking.
*   **Mechanism:** It works like a depth-first search through all possible derivations.
*   **Advantages:**
    *   Conceptually simple and can be implemented by hand.
    *   Can parse a wider range of grammars than non-backtracking parsers.
*   **Disadvantages:**
    *   Extremely inefficient due to repeated parsing of the input, potentially leading to exponential time complexity.
    *   Cannot handle left-recursive grammars as they lead to infinite recursion.
    *   Poor error reporting.

#### Non-Backtracking Parsers
A **non-backtracking parser**, also known as a **predictive parser**, commits to a single production choice based on the next one (or `k`) input token(s). It uses a lookahead token to "predict" which production to apply and does not go back on its choice. If it makes a wrong choice, it is a syntax error.

*   **Types:**
    1.  **Recursive Descent Parser:** A predictive version can be built for a restricted class of grammars (e.g., those that are left-factored and not left-recursive). Each non-terminal is a function that decides which production to use based on the lookahead token.
    2.  **LL(k) Parser:** A more formal, table-driven non-backtracking parser. The "LL" stands for Left-to-right scan of the input and Leftmost derivation. `k` is the number of lookahead tokens (usually 1). An LL(1) parser uses a stack and a parsing table to make its decisions.
*   **Advantages:**
    *   Very efficient, typically running in linear time O(n).
    *   Provide better error messages because an error is detected as soon as the lookahead token does not match any valid production.
*   **Disadvantages:**
    *   Can only parse a restricted class of grammars (LL(k) grammars). The grammar must not be ambiguous or left-recursive and often requires left-factoring.

---

### (b) Construct the SLR Parsing table for the given grammar.

**Grammar:**
```
0. E' -> E
1. E -> E + T
2. E -> T
3. T -> T * F
4. T -> F
5. F -> F^
6. F -> a
7. F -> b
```
*The grammar has been augmented with production 0.*

#### Step 1: Compute FOLLOW Sets
These are needed to determine where to place reduce actions in the table.
*   `FOLLOW(E) = {+, $}` (from `E' -> E` and `E -> E+T`)
*   `FOLLOW(T) = {+, *, $}` (from `E -> E+T`, `E -> T`, and `T -> T*F`)
*   `FOLLOW(F) = {+, *, ^, $}` (from `T -> T*F`, `T -> F`, and `F -> F^`)

#### Step 2: Construct the LR(0) Canonical Collection of Item Sets

*   **I₀ = CLOSURE({E' -> .E})** = `{E' -> .E, E -> .E+T, E -> .T, T -> .T*F, T -> .F, F -> .F^, F -> .a, F -> .b}`
*   **I₁ = GOTO(I₀, E)** = `CLOSURE({E' -> E., E -> E.+T})`
*   **I₂ = GOTO(I₀, T)** = `CLOSURE({E -> T., T -> T.*F})`
*   **I₃ = GOTO(I₀, F)** = `CLOSURE({T -> F., F -> F.^})`
*   **I₄ = GOTO(I₀, a)** = `CLOSURE({F -> a.})`
*   **I₅ = GOTO(I₀, b)** = `CLOSURE({F -> b.})`

*   **I₆ = GOTO(I₁, +)** = `CLOSURE({E -> E+.T})` = `{E -> E+.T, T -> .T*F, T -> .F, F -> .F^, F -> .a, F -> .b}`
*   **I₇ = GOTO(I₂, *)** = `CLOSURE({T -> T*.F})` = `{T -> T*.F, F -> .F^, F -> .a, F -> .b}`
*   **I₈ = GOTO(I₃, ^)** = `CLOSURE({F -> F^.})`

*   **I₉ = GOTO(I₆, T)** = `CLOSURE({E -> E+T., T -> T.*F})`
*   `GOTO(I₆, F)` = I₃
*   `GOTO(I₆, a)` = I₄
*   `GOTO(I₆, b)` = I₅

*   `GOTO(I₇, F)` = `CLOSURE({T -> T*F., F -> F.^})` = **I₁₀**
*   `GOTO(I₇, a)` = I₄
*   `GOTO(I₇, b)` = I₅

*   `GOTO(I₉, *)` = I₇

*   `GOTO(I₁₀, ^)` = I₈

#### Step 3: Construct the SLR Parsing Table

We use the states (I₀ to I₁₀) and FOLLOW sets to build the table.
*   **ACTION Table:** For terminals `+`, `*`, `^`, `a`, `b`, `$`.
*   **GOTO Table:** For non-terminals `E`, `T`, `F`.

| State |       | ACTION |       |       |       |       |   | GOTO |   |
|:-----:|:-----:|:------:|:-----:|:-----:|:-----:|:-----:|:-:|:----:|:-:|
|       | **+** |  **\***  | **^** | **a** | **b** | **$** | **E** | **T** | **F** |
| **0** |       |        |       |  s4   |  s5   |       | 1 |  2   |  3   |
| **1** |  s6   |        |       |       |       | `acc` |   |      |      |
| **2** |  R2   |   s7   |       |       |       |  R2   |   |      |      |
| **3** |  R4   |   R4   |  s8   |       |       |  R4   |   |      |      |
| **4** |  R6   |   R6   |  R6   |       |       |  R6   |   |      |      |
| **5** |  R7   |   R7   |  R7   |       |       |  R7   |   |      |      |
| **6** |       |        |       |  s4   |  s5   |       |   |  9   |  3   |
| **7** |       |        |       |  s4   |  s5   |       |   |      |  10  |
| **8** |  R5   |   R5   |  R5   |       |       |  R5   |   |      |      |
| **9** |  R1   |   s7   |       |       |       |  R1   |   |      |      |
| **10**|  R3   |   R3   |  s8   |       |       |  R3   |   |      |      |

**How to read the table:**
*   `sX`: Shift to state X.
*   `RX`: Reduce by production rule X.
*   `acc`: Accept.
*   Blank entries are error states.
*   The GOTO columns indicate the state to transition to after a reduction. 